{
  "name": "adbkit",
  "version": "2.0.5",
  "description": "A pure Node.js client for the Android Debug Bridge.",
  "keywords": [
    "adb",
    "adbkit",
    "android",
    "logcat",
    "monkey"
  ],
  "bugs": {
    "url": "https://github.com/CyberAgent/adbkit/issues"
  },
  "license": "Apache-2.0",
  "author": {
    "name": "CyberAgent, Inc.",
    "email": "npm@cyberagent.co.jp",
    "url": "http://www.cyberagent.co.jp/"
  },
  "main": "./index",
  "repository": {
    "type": "git",
    "url": "https://github.com/CyberAgent/adbkit.git"
  },
  "scripts": {
    "postpublish": "grunt clean",
    "prepublish": "grunt test coffee",
    "test": "grunt test"
  },
  "dependencies": {
    "adbkit-logcat": "~1.0.0",
    "adbkit-monkey": "~1.0.1",
    "debug": "~0.7.4",
    "split": "~0.2.10",
    "bluebird": "~1.1.0"
  },
  "devDependencies": {
    "bench": "~0.3.5",
    "chai": "~1.9.0",
    "coffee-script": "~1.7.1",
    "grunt": "~0.4.2",
    "grunt-cli": "~0.1.13",
    "grunt-coffeelint": "0.0.8",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-contrib-coffee": "~0.10.0",
    "grunt-contrib-watch": "~0.5.3",
    "grunt-exec": "~0.4.3",
    "grunt-jsonlint": "~1.0.4",
    "grunt-notify": "~0.2.16",
    "mocha": "~1.17.1",
    "sinon": "~1.8.1",
    "sinon-chai": "~2.5.0",
    "coffeelint": "~1.0.8"
  },
  "engines": {
    "node": ">= 0.10.4"
  },
  "readme": "# adbkit\n\n**adbkit** is a pure [Node.js][nodejs] client for the [Android Debug Bridge][adb-site] server. It can be used either as a library in your own application, or simply as a convenient utility for playing with your device.\n\nMost of the `adb` command line tool's functionality is supported (including pushing/pulling files, installing APKs and processing logs), with some added functionality such as being able to generate touch/key events and take screenshots. Some shims are provided for older devices, but we have not and will not test anything below Android 2.3.\n\nInternally, we use this library to drive a multitude of Android devices from a variety of manufacturers, so we can say with a fairly high degree of confidence that it will most likely work with your device(s), too.\n\n# Incompatible changes since 1.x.x\n\nPreviously, we made extensive use of callbacks in almost every feature. While this normally works okay, ADB connections can be quite fickle, and it was starting to become difficult to handle every possible error. For example, we'd often fail to properly clean up after ourselves when a connection suddenly died in an unexpected place, causing memory and resource leaks.\n\nIn version 2, we've replaced nearly all callbacks with [Promises](http://promisesaplus.com/) (using [Bluebird](https://github.com/petkaantonov/bluebird)), allowing for much more reliable error propagation and resource cleanup (thanks to `.finally()`). Additionally, many commands can now be cancelled on the fly, and although unimplemented at this point, we'll also be able to report progress on long-running commands without any changes to the API.\n\nUnfortunately, some API changes were required for this change. `client.framebuffer()`'s callback, for example, previously accepted more than one argument, which doesn't translate into Promises so well. Thankfully, it made sense to combine the arguments anyway, and we were able to do it quite cleanly.\n\nFurthermore, most API methods were returning the current instance for chaining purposes. While perhaps useful in some contexts, most of the time it probably didn't quite do what users expected, as chained calls were run in parallel rather than in serial fashion. Now every applicable API method returns a Promise, which is an incompatible but welcome change. This will also allow you to hook into `yield` and coroutines in Node 0.12.\n\n**However, all methods still accept (and will accept in the future) callbacks for those who prefer them.**\n\nTest coverage was also massively improved, although we've still got ways to go.\n\n## Requirements\n\n* [Node.js][nodejs] >= 0.10\n* The `adb` command line tool\n\nPlease note that although it may happen at some point, **this project is NOT an implementation of the ADB _server_**. The target host (where the devices are connected) must still have ADB installed and either already running (e.g. via `adb start-server`) or available in `$PATH`. An attempt will be made to start the server locally via the aforementioned command if the initial connection fails. This is the only case where we fall back to the `adb` binary.\n\nWhen targeting a remote host, starting the server is entirely your responsibility.\n\nAlternatively, you may want to consider using the Chrome [ADB][chrome-adb] extension, as it includes the ADB server and can be started/stopped quite easily.\n\n## Getting started\n\nInstall via NPM:\n\n```bash\nnpm install --save adbkit\n```\n\nWe use [debug][node-debug], and our debug namespace is `adb`. Some of the dependencies may provide debug output of their own. To see the debug output, set the `DEBUG` environment variable. For example, run your program with `DEBUG=adb:* node app.js`.\n\nNote that even though the module is written in [CoffeeScript][coffeescript], only the compiled JavaScript is published to [NPM][npm], which means that it can easily be used with pure JavaScript codebases, too.\n\n### Examples\n\nThe examples may be a bit verbose, but that's because we're trying to keep them as close to real-life code as possible, with flow control and error handling taken care of.\n\n#### Checking for NFC support\n\n```js\nvar Promise = require('bluebird')\nvar adb = require('adbkit')\nvar client = adb.createClient()\n\nclient.listDevices()\n  .then(function(devices) {\n    return Promise.filter(devices, function(device) {\n      return client.getFeatures(device.id)\n        .then(function(features) {\n          return features['android.hardware.nfc']\n        })\n    })\n  })\n  .then(function(supportedDevices) {\n    console.log('The following devices support NFC:', supportedDevices)\n  })\n  .catch(function(err) {\n    console.error('Something went wrong:', err.stack)\n  })\n```\n\n#### Installing an APK\n\n```js\nvar Promise = require('bluebird')\nvar adb = require('adbkit')\nvar client = adb.createClient()\nvar apk = 'vendor/app.apk'\n\nclient.listDevices()\n  .then(function(devices) {\n    return Promise.map(devices, function(device) {\n      return client.install(device.id, apk)\n    })\n  })\n  .then(function() {\n    console.log('Installed %s on all connected devices', apk)\n  })\n  .catch(function(err) {\n    console.error('Something went wrong:', err.stack)\n  })\n```\n\n#### Tracking devices\n\n```js\nvar adb = require('adbkit')\nvar client = adb.createClient()\n\nclient.trackDevices()\n  .then(function(tracker) {\n    tracker.on('add', function(device) {\n      console.log('Device %s was plugged in', device.id)\n    })\n    tracker.on('remove', function(device) {\n      console.log('Device %s was unplugged', device.id)\n    })\n    tracker.on('end', function() {\n      console.log('Tracking stopped')\n    })\n  })\n  .catch(function(err) {\n    console.error('Something went wrong:', err.stack)\n  })\n```\n\n#### Pulling a file from all connected devices\n\n```js\nvar Promise = require('bluebird')\nvar fs = require('fs')\nvar adb = require('adbkit')\nvar client = adb.createClient()\n\nclient.listDevices()\n  .then(function(devices) {\n    return Promise.map(devices, function(device) {\n      return client.pull(device.id, '/system/build.prop')\n        .then(function(transfer) {\n          return new Promise(function(resolve, reject) {\n            var fn = '/tmp/' + device.id + '.build.prop'\n            transfer.on('progress', function(stats) {\n              console.log('[%s] Pulled %d bytes so far',\n                device.id,\n                stats.bytesTransferred)\n            })\n            transfer.on('end', function() {\n              console.log('[%s] Pull complete', device.id)\n              resolve(device.id)\n            })\n            transfer.on('error', reject)\n            transfer.pipe(fs.createWriteStream(fn))\n          })\n        })\n    })\n  })\n  .then(function() {\n    console.log('Done pulling /system/build.prop from all connected devices')\n  })\n  .catch(function(err) {\n    console.error('Something went wrong:', err.stack)\n  })\n```\n\n#### Pushing a file to all connected devices\n\n```js\nvar Promise = require('bluebird')\nvar adb = require('adbkit')\nvar client = adb.createClient()\n\nclient.listDevices()\n  .then(function(devices) {\n    return Promise.map(devices, function(device) {\n      return client.push(device.id, 'temp/foo.txt', '/data/local/tmp/foo.txt')\n        .then(function(transfer) {\n          return new Promise(function(resolve, reject) {\n            transfer.on('progress', function(stats) {\n              console.log('[%s] Pushed %d bytes so far',\n                device.id,\n                stats.bytesTransferred)\n            })\n            transfer.on('end', function() {\n              console.log('[%s] Push complete', device.id)\n              resolve()\n            })\n            transfer.on('error', reject)\n          })\n        })\n    })\n  })\n  .then(function() {\n    console.log('Done pushing foo.txt to all connected devices')\n  })\n  .catch(function(err) {\n    console.error('Something went wrong:', err.stack)\n  })\n```\n\n#### List files in a folder\n\n```js\nvar Promise = require('bluebird')\nvar adb = require('adbkit')\nvar client = adb.createClient()\n\nclient.listDevices()\n  .then(function(devices) {\n    return Promise.map(devices, function(device) {\n      return client.readdir(device.id, '/sdcard')\n        .then(function(files) {\n          // Synchronous, so we don't have to care about returning at the\n          // right time\n          files.forEach(function(file) {\n            if (file.isFile()) {\n              console.log('[%s] Found file \"%s\"', device.id, file.name)\n            }\n          })\n        })\n    })\n  })\n  .then(function() {\n    console.log('Done checking /sdcard files on connected devices')\n  })\n  .catch(function(err) {\n    console.error('Something went wrong:', err.stack)\n  })\n```\n\n## API\n\n### ADB\n\n#### adb.createClient([options])\n\nCreates a client instance with the provided options. Note that this will not automatically establish a connection, it will only be done when necessary.\n\n* **options** An object compatible with [Net.connect][net-connect]'s options:\n    - **port** The port where the ADB server is listening. Defaults to `5037`.\n    - **host** The host of the ADB server. Defaults to `'localhost'`.\n    - **bin** As the sole exception, this option provides the path to the `adb` binary, used for starting the server locally if initial connection fails. Defaults to `'adb'`.\n* Returns: The client instance.\n\n### Client\n\n#### client.clear(serial, pkg[, callback])\n\nDeletes all data associated with a package from the device. This is roughly analogous to `adb shell pm clear <pkg>`.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **pkg** The package name. This is NOT the APK.\n* **callback(err)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n* Returns: `Promise`\n* Resolves with: `true`\n\n#### client.forward(serial, local, remote[, callback])\n\nForwards socket connections from the ADB server host (local) to the device (remote). This is analogous to `adb forward <local> <remote>`. It's important to note that if you are connected to a remote ADB server, the forward will be created on that host.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **local** A string representing the local endpoint on the ADB host. At time of writing, can be one of:\n    - `tcp:<port>`\n    - `localabstract:<unix domain socket name>`\n    - `localreserved:<unix domain socket name>`\n    - `localfilesystem:<unix domain socket name>`\n    - `dev:<character device name>`\n* **remote** A string representing the remote endpoint on the device. At time of writing, can be one of:\n    - Any value accepted by the `local` argument\n    - `jdwp:<process pid>`\n* **callback(err)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n* Returns: `Promise`\n* Resolves with: `true`\n\n#### client.framebuffer(serial[, format]&#91;, callback])\n\nFetches the current **raw** framebuffer (i.e. what is visible on the screen) from the device, and optionally converts it into something more usable by using [GraphicsMagick][graphicsmagick]'s `gm` command, which must be available in `$PATH` if conversion is desired. Note that we don't bother supporting really old framebuffer formats such as RGB_565. If for some mysterious reason you happen to run into a `>=2.3` device that uses RGB_565, let us know.\n\nNote that high-resolution devices can have quite massive framebuffers. For example, a device with a resolution of 1920x1080 and 32 bit colors would have a roughly 8MB (`1920*1080*4` byte) RGBA framebuffer. Empirical tests point to about 5MB/s bandwidth limit for the ADB USB connection, which means that it can take ~1.6 seconds for the raw data to arrive, or even more if the USB connection is already congested. Using a conversion will further slow down completion.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **format** The desired output format. Any output format supported by [GraphicsMagick][graphicsmagick] (such as `'png'`) is supported. Defaults to `'raw'` for raw framebuffer data.\n* **callback(err, framebuffer)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **framebuffer** The possibly converted framebuffer stream. The stream also has a `meta` property with the following values:\n        * **version** The framebuffer version. Useful for patching possible backwards-compatibility issues.\n        * **bpp** Bits per pixel (i.e. color depth).\n        * **size** The raw byte size of the framebuffer.\n        * **width** The horizontal resolution of the framebuffer. This SHOULD always be the same as screen width. We have not encountered any device with incorrect framebuffer metadata, but according to rumors there might be some.\n        * **height** The vertical resolution of the framebuffer. This SHOULD always be the same as screen height.\n        * **red_offset** The bit offset of the red color in a pixel.\n        * **red_length** The bit length of the red color in a pixel.\n        * **blue_offset** The bit offset of the blue color in a pixel.\n        * **blue_length** The bit length of the blue color in a pixel.\n        * **green_offset** The bit offset of the green color in a pixel.\n        * **green_length** The bit length of the green color in a pixel.\n        * **alpha_offset** The bit offset of alpha in a pixel.\n        * **alpha_length** The bit length of alpha in a pixel. `0` when not available.\n        * **format** The framebuffer format for convenience. This can be one of `'bgr'`,  `'bgra'`, `'rgb'`, `'rgba'`.\n* Returns: `Promise`\n* Resolves with: `framebuffer` (see callback)\n\n#### client.getDevicePath(serial[, callback])\n\nGets the device path of the device identified by the given serial number.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, path)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **path** The device path. This corresponds to the device path in `client.listDevicesWithPaths()`.\n* Returns: `Promise`\n* Resolves with: `path` (see callback)\n\n#### client.getFeatures(serial[, callback])\n\nRetrieves the features of the device identified by the given serial number. This is analogous to `adb shell pm list features`. Useful for checking whether hardware features such as NFC are available (you'd check for `'android.hardware.nfc'`).\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, features)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **features** An object of device features. Each key corresponds to a device feature, with the value being either `true` for a boolean feature, or the feature value as a string (e.g. `'0x20000'` for `reqGlEsVersion`).\n* Returns: `Promise`\n* Resolves with: `features` (see callback)\n\n#### client.getPackages(serial[, callback])\n\nRetrieves the list of packages present on the device. This is analogous to `adb shell pm list packages`. If you just want to see if something's installed, consider using `client.isInstalled()` instead.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, packages)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **packages** An array of package names.\n* Returns: `Promise`\n* Resolves with: `packages` (see callback)\n\n#### client.getProperties(serial[, callback])\n\nRetrieves the properties of the device identified by the given serial number. This is analogous to `adb shell getprop`.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, properties)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **properties** An object of device properties. Each key corresponds to a device property. Convenient for accessing things like `'ro.product.model'`.\n* Returns: `Promise`\n* Resolves with: `properties` (see callback)\n\n#### client.getSerialNo(serial[, callback])\n\nGets the serial number of the device identified by the given serial number. With our API this doesn't really make much sense, but it has been implemented for completeness. _FYI: in the raw ADB protocol you can specify a device in other ways, too._\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, serial)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **serial** The serial number of the device.\n* Returns: `Promise`\n* Resolves with: `serial` (see callback)\n\n#### client.getState(serial[, callback])\n\nGets the state of the device identified by the given serial number.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, state)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **state** The device state. This corresponds to the device type in `client.listDevices()`.\n* Returns: `Promise`\n* Resolves with: `state` (see callback)\n\n#### client.install(serial, apk[, callback])\n\nInstalls the APK on the device, replacing any previously installed version. This is roughly analogous to `adb install -r <apk>`.\n\nNote that if the call seems to stall, you may have to accept a dialog on the phone first.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **apk** When `String`, interpreted as a path to an APK file. When [`Stream`][node-stream], installs directly from the stream, which must be a valid APK.\n* **callback(err)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n* Returns: `Promise`\n* Resolves with: `true`\n\n#### client.installRemote(serial, apk[, callback])\n\nInstalls an APK file which must already be located on the device file system, and replaces any previously installed version. Useful if you've previously pushed the file to the device for some reason (perhaps to have direct access to `client.push()`'s transfer stats). This is roughly analogous to `adb shell pm install -r <apk>` followed by `adb shell rm -f <apk>`.\n\nNote that if the call seems to stall, you may have to accept a dialog on the phone first.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **apk** The path to the APK file on the device. The file will be removed when the command completes.\n* **callback(err)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n* Returns: `Promise`\n* Resolves with: `true`\n\n#### client.isInstalled(serial, pkg[, callback])\n\nTells you if the specific package is installed or not. This is analogous to `adb shell pm path <pkg>` and some output parsing.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **pkg** The package name. This is NOT the APK.\n* **callback(err, installed)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **installed** `true` if the package is installed, `false` otherwise.\n* Returns: `Promise`\n* Resolves with: `installed` (see callback)\n\n#### client.kill([callback])\n\nThis kills the ADB server. Note that the next connection will attempt to start the server again when it's unable to connect.\n\n* **callback(err)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n* Returns: `Promise`\n* Resolves with: `true`\n\n#### client.listDevices([callback])\n\nGets the list of currently connected devices and emulators.\n\n* **callback(err, devices)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **devices** An array of device objects. The device objects are plain JavaScript objects with two properties: `id` and `type`.\n        * **id** The ID of the device. For real devices, this is usually the USB identifier.\n        * **type** The device type. Values include `'emulator'` for emulators, `'device'` for devices, and `'offline'` for offline devices. `'offline'` can occur for example during boot, in low-battery conditions or when the ADB connection has not yet been approved on the device.\n* Returns: `Promise`\n* Resolves with: `devices` (see callback)\n\n#### client.listDevicesWithPaths([callback])\n\nLike `client.listDevices()`, but includes the \"path\" of every device.\n\n* **callback(err, devices)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **devices** An array of device objects. The device objects are plain JavaScript objects with the following properties:\n        * **id** See `client.listDevices()`.\n        * **type** See `client.listDevices()`.\n        * **path** The device path. This can be something like `usb:FD120000` for real devices.\n* Returns: `Promise`\n* Resolves with: `devices` (see callback)\n\n#### client.listForwards(serial[, callback])\n\nLists forwarded connections on the device. This is analogous to `adb forward --list`.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, forwards)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **forwards** An array of forward objects with the following properties:\n        * **serial** The device serial.\n        * **local** The local endpoint. Same format as `client.forward()`'s `local` argument.\n        * **remote** The remote endpoint on the device. Same format as `client.forward()`'s `remote` argument.\n* Returns: `Promise`\n* Resolves with: `forwards` (see callback)\n\n#### client.openLog(serial, name[, callback])\n\nOpens a direct connection to a binary log file, providing access to the raw log data. Note that it is usually much more convenient to use the `client.openLogcat()` method, described separately.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **name** The name of the log. Available logs include `'main'`, `'system'`, `'radio'` and `'events'`.\n* **callback(err, log)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **log** The binary log stream. Call `log.end()` when you wish to stop receiving data.\n* Returns: `Promise`\n* Resolves with: `log` (see callback)\n\n#### client.openLogcat(serial[, callback])\n\nCalls the `logcat` utility on the device and hands off the connection to [adbkit-logcat][adbkit-logcat], a pure Node.js Logcat client. This is analogous to `adb logcat -B`, but the event stream will be parsed for you and a separate event will be emitted for every log entry, allowing for easy processing.\n\nFor more information, check out the [adbkit-logcat][adbkit-logcat] documentation.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, logcat)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **logcat** The Logcat client. Please see the [adbkit-logcat][adbkit-logcat] documentation for details.\n* Returns: `Promise`\n* Resolves with: `logcat` (see callback)\n\n#### client.openMonkey(serial[, port]&#91;, callback])\n\nStarts the built-in `monkey` utility on the device, connects to it using `client.openTcp()` and hands the connection to [adbkit-monkey][adbkit-monkey], a pure Node.js Monkey client. This allows you to create touch and key events, among other things.\n\nFor more information, check out the [adbkit-monkey][adbkit-monkey] documentation.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **port** Optional. The device port where you'd like Monkey to run at. Defaults to `1080`.\n* **callback(err, monkey)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **monkey** The Monkey client. Please see the [adbkit-monkey][adbkit-monkey] documentation for details.\n* Returns: `Promise`\n* Resolves with: `monkey` (see callback)\n\n#### client.openProcStat(serial[, callback])\n\nTracks `/proc/stat` and emits useful information, such as CPU load. A single sync service instance is used to download the `/proc/stat` file for processing. While doing this does consume some resources, it is very light and should not be a problem.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, stats)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **stats** The `/proc/stat` tracker, which is an [`EventEmitter`][node-events]. Call `stat.end()` to stop tracking. The following events are available:\n        * **load** **(loads)** Emitted when a CPU load calculation is available.\n            - **loads** CPU loads of **online** CPUs. Each key is a CPU id (e.g. `'cpu0'`, `'cpu1'`) and the value an object with the following properties:\n                * **user** Percentage (0-100) of ticks spent on user programs.\n                * **nice** Percentage (0-100) of ticks spent on `nice`d user programs.\n                * **system** Percentage (0-100) of ticks spent on system programs.\n                * **idle** Percentage (0-100) of ticks spent idling.\n                * **iowait** Percentage (0-100) of ticks spent waiting for IO.\n                * **irq** Percentage (0-100) of ticks spent on hardware interrupts.\n                * **softirq** Percentage (0-100) of ticks spent on software interrupts.\n                * **steal** Percentage (0-100) of ticks stolen by others.\n                * **guest** Percentage (0-100) of ticks spent by a guest.\n                * **guestnice** Percentage (0-100) of ticks spent by a `nice`d guest.\n                * **total** Total. Always 100.\n* Returns: `Promise`\n* Resolves with: `stats` (see callback)\n\n#### client.openTcp(serial, port[, host]&#91;, callback])\n\nOpens a direct TCP connection to a port on the device, without any port forwarding required.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **port** The port number to connect to.\n* **host** Optional. The host to connect to. Allegedly this is supposed to establish a connection to the given host from the device, but we have not been able to get it to work at all. Skip the host and everything works great.\n* **callback(err, conn)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **conn** The TCP connection (i.e. [`net.Socket`][node-net]). Read and write as you please. Call `conn.end()` to end the connection.\n* Returns: `Promise`\n* Resolves with: `conn` (see callback)\n\n#### client.pull(serial, path[, callback])\n\nA convenience shortcut for `sync.pull()`, mainly for one-off use cases. The connection cannot be reused, resulting in poorer performance over multiple calls. However, the Sync client will be closed automatically for you, so that's one less thing to worry about.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **path** See `sync.pull()` for details.\n* **callback(err, transfer)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **transfer** A `PullTransfer` instance (see below)\n* Returns: `Promise`\n* Resolves with: `transfer` (see callback)\n\n#### client.push(serial, contents, path[, mode]&#91;, callback])\n\nA convenience shortcut for `sync.push()`, mainly for one-off use cases. The connection cannot be reused, resulting in poorer performance over multiple calls. However, the Sync client will be closed automatically for you, so that's one less thing to worry about.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **contents** See `sync.push()` for details.\n* **path** See `sync.push()` for details.\n* **mode** See `sync.push()` for details.\n* **callback(err, transfer)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **transfer** A `PushTransfer` instance (see below)\n* Returns: `Promise`\n* Resolves with: `transfer` (see callback)\n\n#### client.readdir(serial, path[, callback])\n\nA convenience shortcut for `sync.readdir()`, mainly for one-off use cases. The connection cannot be reused, resulting in poorer performance over multiple calls. However, the Sync client will be closed automatically for you, so that's one less thing to worry about.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **path** See `sync.readdir()` for details.\n* **callback(err, files)** Optional. Use this or the returned `Promise`. See `sync.readdir()` for details.\n* Returns: `Promise`\n* Resolves with: See `sync.readdir()` for details.\n\n#### client.remount(serial[, callback])\n\nAttempts to remount the `/system` partition in read-write mode. This will usually only work on emulators and developer devices.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n* Returns: `Promise`\n* Resolves with: `true`\n\n#### client.screencap(serial[, callback])\n\nTakes a screenshot in PNG format using the built-in `screencap` utility. This is analogous to `adb shell screencap -p`. Sadly, the utility is not available on most Android `<=2.3` devices, but a silent fallback to the `client.framebuffer()` command in PNG mode is attempted, so you should have its dependencies installed just in case.\n\nGenerating the PNG on the device naturally requires considerably more processing time on that side. However, as the data transferred over USB easily decreases by ~95%, and no conversion being required on the host, this method is usually several times faster than using the framebuffer. Naturally, this benefit does not apply if we're forced to fall back to the framebuffer.\n\nFor convenience purposes, if the screencap command fails (e.g. because it doesn't exist on older Androids), we fall back to `client.framebuffer(serial, 'png')`, which is slower and has additional installation requirements.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, screencap)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **screencap** The PNG stream.\n* Returns: `Promise`\n* Resolves with: `screencap` (see callback)\n\n#### client.shell(serial, command[, callback])\n\nRuns a shell command on the device. Note that you'll be limited to the permissions of the `shell` user, which ADB uses.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **command** The shell command to execute. When `String`, the command is run as-is. When `Array`, the elements will be rudimentarily escaped (for convenience, not security) and joined to form a command.\n* **callback(err, output)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **output** An output [`Stream`][node-stream] in non-flowing mode. Unfortunately it is not possible to separate stdout and stderr, you'll get both of them in one stream. It is also not possible to access the exit code of the command. If access to any of these individual properties is needed, the command must be constructed in a way that allows you to parse the information from the output.\n* Returns: `Promise`\n* Resolves with: `output` (see callback)\n\n#### client.startActivity(serial, options[, callback])\n\nStarts the configured activity on the device. Roughly analogous to `adb shell am start <options>`.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **options** The activity configuration. The following options are available:\n    - **action** The action.\n    - **category** The category. For multiple categories, pass an `Array`.\n    - **component** The component.\n    - **flags** Numeric flags.\n    - **extras** Any extra data.\n        * When an `Array`, each item must be an `Object` the following properties:\n            - **key** The key name.\n            - **type** The type, which can be one of `'string'`, `'null'`, `'bool'`, `'int'`, `'long'`, `'float'`, `'uri'`, `'component'`.\n            - **value** The value. Optional and unused if type is `'null'`. If an `Array`, type is automatically set to be an array of `<type>`.\n        * When an `Object`, each key is treated as the key name. Simple values like `null`, `String`, `Boolean` and `Number` are type-mapped automatically (`Number` maps to `'int'`) and can be used as-is. For more complex types, like arrays and URIs, set the value to be an `Object` like in the Array syntax (see above), but leave out the `key` property.\n* **callback(err)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n* Returns: `Promise`\n* Resolves with: `true`\n\n#### client.stat(serial, path[, callback])\n\nA convenience shortcut for `sync.stat()`, mainly for one-off use cases. The connection cannot be reused, resulting in poorer performance over multiple calls. However, the Sync client will be closed automatically for you, so that's one less thing to worry about.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **path** See `sync.stat()` for details.\n* **callback(err, stats)** Optional. Use this or the returned `Promise`. See `sync.stat()` for details.\n* Returns: `Promise`\n* Resolves with: See `sync.stat()` for details.\n\n#### client.syncService(serial[, callback])\n\nEstablishes a new Sync connection that can be used to push and pull files. This method provides the most freedom and the best performance for repeated use, but can be a bit cumbersome to use. For simple use cases, consider using `client.stat()`, `client.push()` and `client.pull()`.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err, sync)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **sync** The Sync client. See below for details. Call `sync.end()` when done.\n* Returns: `Promise`\n* Resolves with: `sync` (see callback)\n\n#### client.trackDevices([callback])\n\nGets a device tracker. Events will be emitted when devices are added, removed, or their type changes (i.e. to/from `offline`). Note that the same events will be emitted for the initially connected devices also, so that you don't need to use both `client.listDevices()` and `client.trackDevices()`.\n\nNote that as the tracker will keep a connection open, you must call `tracker.end()` if you wish to stop tracking devices.\n\n* **callback(err, tracker)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **tracker** The device tracker, which is an [`EventEmitter`][node-events]. The following events are available:\n        * **add** **(device)** Emitted when a new device is connected, once per device. See `client.listDevices()` for details on the device object.\n        * **remove** **(device)** Emitted when a device is unplugged, once per device. This does not include `offline` devices, those devices are connected but unavailable to ADB. See `client.listDevices()` for details on the device object.\n        * **change** **(device)** Emitted when the `type` property of a device changes, once per device. The current value of `type` is the new value. This event usually occurs the type changes from `'device'` to `'offline'` or the other way around. See `client.listDevices()` for details on the device object and the `'offline'` type.\n        * **changeSet** **(changes)** Emitted once for all changes reported by ADB in a single run. Multiple changes can occur when, for example, a USB hub is connected/unplugged and the device list changes quickly. If you wish to process all changes at once, use this event instead of the once-per-device ones. Keep in mind that the other events will still be emitted, though.\n            - **changes** An object with the following properties always present:\n                * **added** An array of added device objects, each one as in the `add` event. Empty if none.\n                * **removed** An array of removed device objects, each one as in the `remove` event. Empty if none.\n                * **changed** An array of changed device objects, each one as in the `change` event. Empty if none.\n        * **end** Emitted when the underlying connection ends.\n        * **error** **(err)** Emitted if there's an error.\n* Returns: `Promise`\n* Resolves with: `tracker` (see callback)\n\n#### client.uninstall(serial, pkg[, callback])\n\nUninstalls the package from the device. This is roughly analogous to `adb uninstall <pkg>`.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **pkg** The package name. This is NOT the APK.\n* **callback(err)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n* Returns: `Promise`\n* Resolves with: `true`\n\n#### client.version([callback])\n\nQueries the ADB server for its version. This is mainly useful for backwards-compatibility purposes.\n\n* **callback(err, version)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **version** The version of the ADB server.\n* Returns: `Promise`\n* Resolves with: `version` (see callback)\n\n#### client.waitBootComplete(serial[, callback])\n\nWaits until the device has finished booting. Note that the device must already be seen by ADB. This is roughly analogous to periodically checking `adb shell getprop sys.boot_completed`.\n\n* **serial** The serial number of the device. Corresponds to the device ID in `client.listDevices()`.\n* **callback(err)** Optional. Use this or the returned `Promise`.\n    - **err** `null` if the device has completed booting, `Error` otherwise (can occur if the connection dies while checking).\n* Returns: `Promise`\n* Resolves with: `true`\n\n### Sync\n\n#### sync.end()\n\nCloses the Sync connection, allowing Node to quit (assuming nothing else is keeping it alive, of course).\n\n* Returns: The sync instance.\n\n#### sync.pull(path)\n\nPulls a file from the device as a `PullTransfer` [`Stream`][node-stream].\n\n* **path** The path to pull from.\n* Returns: A `PullTransfer` instance. See below for details.\n\n#### sync.push(contents, path[, mode])\n\nAttempts to identify `contents` and calls the appropriate `push*` method for it.\n\n* **contents** When `String`, treated as a local file path and forwarded to `sync.pushFile()`. Otherwise, treated as a [`Stream`][node-stream] and forwarded to `sync.pushStream()`.\n* **path** The path to push to.\n* **mode** Optional. The mode of the file. Defaults to `0644`.\n* Returns: A `PushTransfer` instance. See below for details.\n\n#### sync.pushFile(file, path[, mode])\n\nPushes a local file to the given path. Note that the path must be writable by the ADB user (usually `shell`). When in doubt, use `'/data/local/tmp'` with an appropriate filename.\n\n* **file** The local file path.\n* **path** See `sync.push()` for details.\n* **mode** See `sync.push()` for details.\n* Returns: See `sync.push()` for details.\n\n#### sync.pushStream(stream, path[, mode])\n\nPushes a [`Stream`][node-stream] to the given path. Note that the path must be writable by the ADB user (usually `shell`). When in doubt, use `'/data/local/tmp'` with an appropriate filename.\n\n* **stream** The readable stream.\n* **path** See `sync.push()` for details.\n* **mode** See `sync.push()` for details.\n* Returns: See `sync.push()` for details.\n\n#### sync.readdir(path[, callback])\n\nRetrieves a list of directory entries (e.g. files) in the given path, not including the `.` and `..` entries, just like [`fs.readdir`][node-fs]. If given a non-directory path, no entries are returned.\n\n* **path** The path.\n* **callback(err, files)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **files** An `Array` of [`fs.Stats`][node-fs-stats]-compatible instances. While the `stats.is*` methods are available, only the following properties are supported (in addition to the `name` field which contains the filename):\n        * **name** The filename.\n        * **mode** The raw mode.\n        * **size** The file size.\n        * **mtime** The time of last modification as a `Date`.\n* Returns: `Promise`\n* Resolves with: `files` (see callback)\n\n#### sync.stat(path[, callback])\n\nRetrieves information about the given path.\n\n* **path** The path.\n* **callback(err, stats)** Optional. Use this or the returned `Promise`.\n    - **err** `null` when successful, `Error` otherwise.\n    - **stats** An [`fs.Stats`][node-fs-stats] instance. While the `stats.is*` methods are available, only the following properties are supported:\n        * **mode** The raw mode.\n        * **size** The file size.\n        * **mtime** The time of last modification as a `Date`.\n* Returns: `Promise`\n* Resolves with: `stats` (see callback)\n\n#### sync.tempFile(path)\n\nA simple helper method for creating appropriate temporary filenames for pushing files. This is essentially the same as taking the basename of the file and appending it to `'/data/local/tmp/'`.\n\n* **path** The path of the file.\n* Returns: An appropriate temporary file path.\n\n### PushTransfer\n\nA simple EventEmitter, mainly for keeping track of the progress.\n\nList of events:\n\n* **progress** **(stats)** Emitted when a chunk has been flushed to the ADB connection.\n    - **stats** An object with the following stats about the transfer:\n        * **bytesTransferred** The number of bytes transferred so far.\n* **error** **(err)** Emitted on error.\n    - **err** An `Error`.\n* **end** Emitted when the transfer has successfully completed.\n\n#### pushTransfer.cancel()\n\nCancels the transfer by ending both the stream that is being pushed and the sync connection. This will most likely end up creating a broken file on your device. **Use at your own risk.** Also note that you must create a new sync connection if you wish to continue using the sync service.\n\n* Returns: The pushTransfer instance.\n\n### PullTransfer\n\n`PullTransfer` is a [`Stream`][node-stream]. Use [`fs.createWriteStream()`][node-fs] to pipe the stream to a file if necessary.\n\nList of events:\n\n* **progress** **(stats)** Emitted when a new chunk is received.\n    - **stats** An object with the following stats about the transfer:\n        * **bytesTransferred** The number of bytes transferred so far.\n* **error** **(err)** Emitted on error.\n    - **err** An `Error`.\n* **end** Emitted when the transfer has successfully completed.\n\n#### pullTransfer.cancel()\n\nCancels the transfer by ending the connection. Can be useful for reading endless streams of data, such as `/dev/urandom` or `/dev/zero`, perhaps for benchmarking use. Note that you must create a new sync connection if you wish to continue using the sync service.\n\n* Returns: The pullTransfer instance.\n\n## More information\n\n* [Android Debug Bridge][adb-site]\n    - [SERVICES.TXT][adb-services] (ADB socket protocol)\n* [Android ADB Protocols][adb-protocols] (a blog post explaining the protocol)\n* [adb.js][adb-js] (another Node.js ADB implementation)\n* [ADB Chrome extension][chrome-adb]\n\n## Contributing\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md).\n\n## License\n\nSee [LICENSE](LICENSE).\n\nCopyright © CyberAgent, Inc. All Rights Reserved.\n\n[nodejs]: <http://nodejs.org/>\n[coffeescript]: <http://coffeescript.org/>\n[npm]: <https://npmjs.org/>\n[adb-js]: <https://github.com/flier/adb.js>\n[adb-site]: <http://developer.android.com/tools/help/adb.html>\n[adb-services]: <https://github.com/android/platform_system_core/blob/master/adb/SERVICES.TXT>\n[adb-protocols]: <http://blogs.kgsoft.co.uk/2013_03_15_prg.htm>\n[file_sync_service.h]: <https://github.com/android/platform_system_core/blob/master/adb/file_sync_service.h>\n[chrome-adb]: <https://chrome.google.com/webstore/detail/adb/dpngiggdglpdnjdoaefidgiigpemgage>\n[node-debug]: <https://npmjs.org/package/debug>\n[net-connect]: <http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener>\n[node-events]: <http://nodejs.org/api/events.html>\n[node-stream]: <http://nodejs.org/api/stream.html>\n[node-net]: <http://nodejs.org/api/net.html>\n[node-fs]: <http://nodejs.org/api/fs.html>\n[node-fs-stats]: <http://nodejs.org/api/fs.html#fs_class_fs_stats>\n[node-gm]: <https://github.com/aheckmann/gm>\n[graphicsmagick]: <http://www.graphicsmagick.org/>\n[imagemagick]: <http://www.imagemagick.org/>\n[adbkit-logcat]: <https://npmjs.org/package/adbkit-logcat>\n[adbkit-monkey]: <https://npmjs.org/package/adbkit-monkey>\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/CyberAgent/adbkit",
  "_id": "adbkit@2.0.5",
  "dist": {
    "shasum": "be96d00d04e20780df799d72e5bb79d338b9f461"
  },
  "_from": "adbkit@",
  "_resolved": "https://registry.npmjs.org/adbkit/-/adbkit-2.0.5.tgz"
}
